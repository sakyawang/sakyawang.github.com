<?xml version="1.0"  encoding="UTF-8"?>
<rss version="2.0">  <channel>
    <title>王浩的小课桌</title>
    <link>http://sakyawang.github.io</link>
    <pubDate>28 Jul 15 23:41 CST</pubDate>
    <item>
      <title>设计模式解读之一： 策略模式</title>
      <link>http://sakyawang.github.io/设计模式/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E8%AF%BB%E4%B9%8B%E4%B8%80%EF%BC%9A-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>2015-07-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;转自：&lt;a href=&#34;http://www.javaeye.com/topic/328262&#34;&gt;http://www.javaeye.com/topic/328262&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当我们掌握了Java的语法，当我们了解了面向对象的封装、继承、多态等特性，当我们可以用Swing、Servlet、JSP技术构建桌面以及Web应用，不意味着我们可以写出面向对象的程序，不意味着我们可以很好的实现代码复用，弹性维护，不意味着我们可以实现在维护、扩展基础上的代码复用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一把刀，可以使你制敌于无形而于江湖扬名，也可以只是一把利刃而使你切菜平静。Java，就是这把刀，它的威力取决于你使用的方式。当我们陷入无尽无止重复代码的泥沼，当我们面临牵一发而动全身的维护恶梦, 你应该想起“设计模式”这个行动秘笈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;面向对象的精义，看似平淡，其实要经过艰苦实践才能成功。而构造OO系统的隐含经验于是被前人搜集而成并冠以“设计模式”之名。我们应该在编码行动初始就携带以它。接下来，让我们步“四人组”先行者之后，用中国文字、用实际案例领略模式于我们代码焕然一新的改变。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;设计模式解读之一： 策略模式&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1. 模式定义&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把会变化的内容取出并封装起来，以便以后可以轻易地改动或扩充部分，而不影响不需要变化的其他部分；&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2. 问题缘起&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当涉及至代码维护时，为了复用目的而使用继承，结局并不完美。对父类的修改，会影响到子类型。在超类中增加的方法，会导致子类型有该方法，甚至连那些不该具备该方法的子类型也无法免除。示例，一个鸭子类型：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class Duck {&#xA;    //所有的鸭子均会叫以及游泳，所以父类中处理这部分代码&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack&amp;quot;);&#xA;    }&#xA;&#xA;    public void swim() {&#xA;        System.out.println(&amp;quot;All ducks float, even decoys.&amp;quot;);        &#xA;    }&#xA;&#xA;    //因为每种鸭子的外观是不同的，所以父类中该方法是抽象的，由子类型自己完成。&#xA;    public abstract void display();&#xA;}&#xA;&#xA;public class MallardDuck extends Duck {&#xA;    //野鸭外观显示为绿头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Green head.&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;public class RedHeadDuck extends Duck {&#xA;    //红头鸭显示为红头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Red head.&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;public class RubberDuck extends Duck {&#xA;    //橡皮鸭叫声为吱吱叫，所以重写父类以改写行为&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Squeak&amp;quot;);&#xA;    }&#xA;&#xA;    //橡皮鸭显示为黄头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Yellow head.&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述代码，初始实现得非常好。现在我们如果给Duck.java中加入fly()方法的话，那么在子类型中均有了该方法，于是我们看到了 会飞的橡皮鸭子，你看过吗？当然，我们可以在子类中通过空实现重写该方法以解决该方法对于子类型的影响。但是父类中再增加其它的方法呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过继承在父类中提供行为，会导致以下缺点：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代码在多个子类中重复;&lt;/li&gt;&#xA;&lt;li&gt;运行时的行为不容易改变；&lt;/li&gt;&#xA;&lt;li&gt;改变会牵一发动全身，造成部分子类型不想要的改变；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;好啦，还是刚才鸭子的例子，你也许想到使用接口，将飞的行为、叫的行为定义为接口，然后让Duck的各种子类型实现这些接口。这时侯代码类似于：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public abstract class Duck {&#xA;    //将变化的行为 fly() 以及quake()从Duck类中分离出去定义形成接口，有需求的子类中自行去实现&#xA;&#xA;    public void swim() {&#xA;        System.out.println(&amp;quot;All ducks float, even decoys.&amp;quot;);        &#xA;    }&#xA;&#xA;    public abstract void display();&#xA;}&#xA;&#xA;//变化的 fly() 行为定义形成的接口&#xA;public interface FlyBehavior {&#xA;    void fly();&#xA;}&#xA;&#xA;//变化的 quack() 行为定义形成的接口&#xA;public interface QuackBehavior {&#xA;    void quack();&#xA;}&#xA;&#xA;//野鸭子会飞以及叫，所以实现接口  FlyBehavior, QuackBehavior&#xA;public class MallardDuck extends Duck implements FlyBehavior, QuackBehavior{&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Green head.&amp;quot;);&#xA;    }&#xA;&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;Fly.&amp;quot;);                &#xA;    }&#xA;&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack.&amp;quot;);                &#xA;    }&#xA;}&#xA;&#xA;//红头鸭子会飞以及叫，所以也实现接口  FlyBehavior, QuackBehavior&#xA;public class RedHeadDuck extends Duck implements FlyBehavior, QuackBehavior{&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Red head.&amp;quot;);&#xA;    }    &#xA;&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;Fly.&amp;quot;);                &#xA;    }&#xA;&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack.&amp;quot;);                &#xA;    }    &#xA;}&#xA;&#xA;//橡皮鸭不会飞，但会吱吱叫，所以只实现接口QuackBehavior&#xA;public class RubberDuck extends Duck implements QuackBehavior{&#xA;    //橡皮鸭叫声为吱吱叫&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Squeak&amp;quot;);&#xA;    }&#xA;&#xA;    //橡皮鸭显示为黄头&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Yellow head.&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上述代码虽然解决了一部分问题，让子类型可以有选择地提供一些行为(例如 fly() 方法将不会出现在橡皮鸭中).但我们也看到，野鸭子MallardDuck.java和红头鸭子RedHeadDuck.java的一些相同行为代码不能得到重复使用。很大程度上这是从一个火坑跳到另一个火坑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在一段程序之后，让我们从细节中跳出来，关注一些共性问题。不管使用什么语言，构建什么应用，在软件开发上，一直伴随着的不变的真理是：需要一直在变化。不管当初软件设计得多好，一段时间之后，总是需要成长与改变，否则软件就会死亡。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们知道，继承在某种程度上可以实现代码重用，但是父类(例如鸭子类Duck)的行为在子类型中是不断变化的，让所有子类型都有这些行为是不恰当的。我们可以将这些行为定义为接口，让Duck的各种子类型去实现，但接口不具有实现代码，所以实现接口无法达到代码复用。这意味着，当我们需要修改某个行为，必须往下追踪并在每一个定义此行为的类中修改它，一不小心，会造成新的错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设计原则：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;把应用中变化的地方独立出来，不要和那些不需要变化的代码混在一起。&#xA;这样代码变化引起的不经意后果变少，系统变得更有弹性。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;按照上述设计原则，我们重新审视之前的Duck代码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;1) 分开变化的内容和不变的内容&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Duck类中的行为 fly(), quack(), 每个子类型可能有自己特有的表现，这就是所谓的变化的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Duck类中的行为 swim() 每个子类型的表现均相同，这就是所谓不变的内容。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们将变化的内容从Duck()类中剥离出来单独定义形成接口以及一系列的实现类型。将变化的内容定义形成接口可实现变化内容和不变内容的剥离。其实现类型可实现变化内容的重用。这些实现类并非Duck.java的子类型，而是专门的一组实现类，称之为&amp;rdquo;行为类&amp;rdquo;。由行为类而不是Duck.java的子类型来实现接口。这样，才能保证变化的行为独立于不变的内容。于是我们有：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;变化的内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   //变化的 fly() 行为定义形成的接口&#xA;   public interface FlyBehavior {&#xA;    void fly();&#xA;   }&#xA;&#xA;   //变化的 fly() 行为的实现类之一&#xA;   public class FlyWithWings implements FlyBehavior {&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;I&#39;m flying.&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;   //变化的 fly() 行为的实现类之二&#xA;   public class FlyNoWay implements FlyBehavior {&#xA;    public void fly() {&#xA;        System.out.println(&amp;quot;I can&#39;t fly.&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;       -----------------------------------------------------------------&#xA;&#xA;   //变化的 quack() 行为定义形成的接口&#xA;   public interface QuackBehavior {&#xA;    void quack();&#xA;   }&#xA;&#xA;   //变化的 quack() 行为实现类之一&#xA;   public class Quack implements QuackBehavior {&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Quack&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;   //变化的 quack() 行为实现类之二&#xA;   public class Squeak implements QuackBehavior {&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;Squeak.&amp;quot;);&#xA;    }&#xA;   }&#xA;&#xA;   //变化的 quack() 行为实现类之三&#xA;   public class MuteQuack implements QuackBehavior {&#xA;    public void quack() {&#xA;        System.out.println(&amp;quot;&amp;lt;&amp;lt; Slience &amp;gt;&amp;gt;&amp;quot;);&#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;通过以上设计，fly()行为以及quack()行为已经和Duck.java没有什么关系，可以充分得到复用。而且我们很容易增加新的行为, 既不影响现有的行为，也不影响Duck.java。但是，大家可能有个疑问，就是在面向对象中行为不是体现为方法吗？为什么现在被定义形成类(例如Squeak.java)？在OO中，类代表的&amp;rdquo;东西&amp;rdquo;一般是既有状态(实例变量）又有方法。只是在本例中碰巧&amp;rdquo;东西&amp;rdquo;是个行为。既使是行为，也有属性及方法，例如飞行行为，也需要一些属性记录飞行的状态，如飞行高度、速度等。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;2) 整合变化的内容和不变的内容&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Duck.java将 fly()以及quack()的行为委拖给行为类处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不变的内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public abstract class Duck {&#xA;        //将行为类声明为接口类型，降低对行为实现类型的依赖&#xA;    FlyBehavior flyBehavior;&#xA;    QuackBehavior quackBehavior;&#xA;&#xA;    public void performFly() {&#xA;        //不自行处理fly()行为，而是委拖给引用flyBehavior所指向的行为对象&#xA;        flyBehavior.fly();&#xA;    }&#xA;&#xA;    public void performQuack() {&#xA;        quackBehavior.quack();&#xA;    }&#xA;&#xA;    public void swim() {&#xA;        System.out.println(&amp;quot;All ducks float, even decoys.&amp;quot;);        &#xA;    }&#xA;&#xA;    public abstract void display();&#xA;   }&#xA;&#xA;   Duck.java不关心如何进行 fly()以及quack(), 这些细节交由具体的行为类完成。&#xA;&#xA;   public class MallardDuck extends Duck{&#xA;    public MallardDuck() {&#xA;        flyBehavior=new FlyWithWings();&#xA;        quackBehavior=new Quack();        &#xA;    }&#xA;&#xA;    public void display() {&#xA;        System.out.println(&amp;quot;Green head.&amp;quot;);&#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试类：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public class DuckTest {&#xA;    public static void main(String[] args) {&#xA;        Duck duck=new MallardDuck();&#xA;        duck.performFly();&#xA;        duck.performQuack();        &#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Duck.java子类型MallardDuck.java的构造方法中，直接实例化行为类型，在编译的时侯便指定具体行为类型。当然，我们可以：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;我们可以通过工厂模式或其它模式进一步解藕(可参考后续模式讲解);&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;或做到在运行时动态地改变行为。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;3) 动态设定行为&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在父类Duck.java中增加设定行为类型的setter方法，接受行为类型对象的参数传入。为了降藕，行为参数被声明为接口类型。这样，既便在运行时，也可以通过调用这二个方法以改变行为。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public abstract class Duck {&#xA;    //在刚才Duck.java中加入以下二个方法。&#xA;    public void setFlyBehavior(FlyBehavior flyBehavior) {&#xA;        this.flyBehavior=flyBehavior;&#xA;    }&#xA;&#xA;    public void setQuackBehavior(QuackBehavior quackBehavior) {&#xA;        this.quackBehavior=quackBehavior;&#xA;    }&#xA;&#xA;    //其它方法同，省略...&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;测试类：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   public class DuckTest {&#xA;    public static void main(String[] args) {&#xA;        Duck duck=new MallardDuck();&#xA;        duck.performFly();&#xA;        duck.performQuack();&#xA;        duck.setFlyBehavior(new FlyNoWay());&#xA;        duck.performFly();&#xA;    }&#xA;   }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果，我们要加上火箭助力的飞行行为，只需再新建FlyBehavior.java接口的实现类型。而子类型可通过调用setQuackBehavior(&amp;hellip;)方法动态改变。至此，在Duck.java增加新的行为给我们代码所带来的困绕已不复存在。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;该是总结的时侯了，让我们从代码的水中浮出来，做一只在水面上自由游动的鸭子吧:&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;3.  解决方案&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MallardDuck 继承  Duck抽象类；          -&amp;gt; 不变的内容&lt;/li&gt;&#xA;&lt;li&gt;FlyWithWings 实现 FlyBehavior接口；     -&amp;gt; 变化的内容,行为或算法&lt;/li&gt;&#xA;&lt;li&gt;在Duck.java提供setter方法以装配关系；    -&amp;gt; 动态设定行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;以上就是策略模式的实现三步曲。接下来，让我们透过步骤看本质:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始，我们通过继承实现行为的重用，导致了代码的维护问题。          -&amp;gt; 继承, is a&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;接着，我们将行为剥离成单独的类型并声明为不变内容的实例变量并通过  -&amp;gt; 组合, has a&#xA;setter方法以装配关系；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;继承，可以实现静态代码的复用；&#xA;组合，可以实现代码的弹性维护；&#xA;使用组合代替继承，可以使代码更好地适应软件开发完后的需求变化。&#xA;策略模式的本质：少用继承，多用组合&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>stack的三种含义</title>
      <link>http://sakyawang.github.io/转载/stack%E7%9A%84%E4%B8%89%E7%A7%8D%E5%90%AB%E4%B9%89/</link>
      <pubDate>2015-07-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文来自：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/11/stack.html&#34;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如有引用请注明，谢谢！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;#stack的三种含义&lt;/p&gt;&#xA;&#xA;&lt;p&gt;学习编程的时候，经常会看到stack这个词，它的中文名字叫做&amp;rdquo;栈&amp;rdquo;。&#xA;理解这个概念，对于理解程序的运行至关重要。容易混淆的是，这个词其实有三种含义，适用于不同的场合，必须加以区分。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;含义一：数据结构&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;stack的第一种含义是一组数据的&lt;a href=&#34;http://en.wikipedia.org/wiki/Stack_(abstract_data_type&#34;&gt;存放方式&lt;/a&gt;)，特点为LIFO，即后进先出（Last in, first out）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112901.png&#34; alt=&#34;stack&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这种数据结构中，数据像积木那样一层层堆起来，后面加入的数据就放在最上层。使用的时候，最上层的数据第一个被用掉，这就叫做&amp;rdquo;后进先出&amp;rdquo;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;与这种结构配套的，是一些特定的方法，主要为下面这些。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;push：在最顶层加入数据。&#xA;pop：返回并移除最顶层的数据。&#xA;top：返回最顶层数据的值，但不移除它。&#xA;isempty：返回一个布尔值，表示当前stack是否为空栈。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;含义二：代码运行方式&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;stack的第二种含义是&lt;a href=&#34;http://en.wikipedia.org/wiki/Call_stack&#34;&gt;&amp;ldquo;调用栈&amp;rdquo;&lt;/a&gt;（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。&#xA;下面以一段Java代码为例（&lt;a href=&#34;http://www.itcsolutions.eu/2011/02/06/tutorial-java-8-understand-stack-and-heap/&#34;&gt;来源&lt;/a&gt;）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;class Student{&#xA;    int age;              &#xA;    String name;      &#xA;&#xA;    public Student(int Age, String Name)&#xA;    {&#xA;        this.age = Age;&#xA;        setName(Name);&#xA;    }&#xA;    public void setName(String Name)&#xA;    {&#xA;        this.name = Name;&#xA;    }&#xA;}&#xA;&#xA;public class Main{&#xA;    public static void main(String[] args) {&#xA;            Student s;           &#xA;            s = new Student(23,&amp;quot;Jonh&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这段代码运行的时候，首先调用main方法，里面需要生成一个Student的实例，于是又调用Student构造函数。在构造函数中，又调用到setName方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112902.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这三次调用像积木一样堆起来，就叫做&amp;rdquo;调用栈&amp;rdquo;。程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;含义三：内存区域&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;stack的第三种含义是&lt;a href=&#34;http://en.wikipedia.org/wiki/Stack-based_memory_allocation&#34;&gt;存放数据的一种内存区域&lt;/a&gt;。程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做stack（栈），另一种叫做heap（堆）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112903.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;它们的主要区别是：stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap是没有结构的，数据可以任意存放。因此，stack的寻址速度要快于heap。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112904.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他的区别还有，一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据上面这些区别，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面。请看下面这段代码（&lt;a href=&#34;http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types&#34;&gt;来源&lt;/a&gt;）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void Method1()&#xA;{&#xA;    int i=4;&#xA;&#xA;    int y=2;&#xA;&#xA;    class1 cls1 = new class1();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面代码的Method1方法，共包含了三个变量：i, y 和 cls1。其中，i和y的值是整数，内存占用空间是确定的，而且是局部变量，只用在Method1区块之内，不会用于区块之外。cls1也是局部变量，但是类型为指针变量，指向一个对象的实例。指针变量占用的大小是确定的，但是对象实例以目前的信息无法确知所占用的内存空间大小。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这三个变量和一个对象实例在内存中的存放方式如下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201311/bg2013112905.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从上图可以看到，i、y和cls1都存放在stack，因为它们占用内存空间都是确定的，而且本身也属于局部变量。但是，cls1指向的对象实例存放在heap，因为它的大小不确定。作为一条规则可以记住，所有的对象都存放在heap。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接下来的问题是，当Method1方法运行结束，会发生什么事？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;回答是整个stack被清空，i、y和cls1这三个变量消失，因为它们是局部变量，区块一旦运行结束，就没必要再存在了。而heap之中的那个对象实例继续存在，直到系统的垃圾清理机制（garbage collector）将这块内存回收。因此，一般来说，内存泄漏都发生在heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>使用sublime text2 编辑markdown文件并导出带目录的html</title>
      <link>http://sakyawang.github.io/markdown/%E4%BD%BF%E7%94%A8sublime-text2-%E7%BC%96%E8%BE%91markdown%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%87%BA%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84html/</link>
      <pubDate>2015-07-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;前一篇文章介绍了使用markdown pad2来生成带目录的html文件。但是有很多程序员喜欢使用sublime来进行markdown的编写。这里介绍一下sublime下如何把markdown文件生成带目录的html。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、 sublime text2&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置过程&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;sublime text 安装 markdown preview插件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;sublime text 安装插件基本配置请参看之前的一篇文章：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://sakyawang.github.io/sublime/sublime-text2-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/&#34;&gt;sublime text2 安装插件&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ctrl+shift+P 调出窗口，输入 install package &amp;ndash;&amp;gt; 输入 markdown preview 选中安装插件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;配置markdown高亮显示&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在Preferences -&amp;gt;Package Settings-&amp;gt;Markdown Preview-&amp;gt;Setting Default中找到&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;quot;enable_mathjax&amp;quot;: true,&#xA;&#xA;/*&#xA;    Enable uml support scripts: flowchart.js and sequence-diagram.js.&#xA;*/&#xA;&amp;quot;enable_uml&amp;quot;: false,&#xA;&#xA;/*&#xA;    Enable highlighting. This enables codehilite extension if not already enabled.&#xA;*/&#xA;&amp;quot;enable_highlight&amp;quot;: true,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;enable_mathjax 和 enable_highlight设置为true。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;编写markdown输出带目录的html&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;新建test.md文件，输入测试内容：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[TOC]&#xA;# 标题 #&#xA;## 标题1 ##&#xA;&#xA;标题1内容&#xA;&#xA;### 标题11 ###&#xA;&#xA;标题11内容&#xA;&#xA;### 标题12 ###&#xA;&#xA;标题12内容&#xA;&#xA;## 标题2 ##&#xA;&#xA;标题2内容&#xA;&#xA;### 标题21 ###&#xA;&#xA;标题21内容&#xA;&#xA;### 标题22 ###&#xA;&#xA;标题22内容&#xA;&#xA;## 标题3 ##&#xA;&#xA;标题3内容&#xA;&#xA;### 标题31 ###&#xA;&#xA;标题31内容&#xA;&#xA;### 标题32 ###&#xA;&#xA;标题32内容&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置markdown preview编译生成html文件，如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/sublimeconfig.png&#34; alt=&#34;配置markdown编译&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行ctrl + B编译markdown为html&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/buildmarkdown.png&#34; alt=&#34;编译markdown&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开test.html查看效果&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/testhtml.jpg&#34; alt=&#34;效果&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;关键点是在要生成目录的位置添加[TOC]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>markdown pad 生成带目录的html</title>
      <link>http://sakyawang.github.io/markdown/markdown-pad-%E7%94%9F%E6%88%90%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%9A%84html/</link>
      <pubDate>2015-07-16 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、markdown pad 2&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;目的&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用markdown pad 2编辑生成wiki风格的接口文档&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;处理方案&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用markdown pad 2的导出功能和高级设置的Html head 编辑器功能。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;工具&amp;ndash;&amp;gt;选项&amp;ndash;&amp;gt;高级&amp;ndash;&amp;gt;Html head 编辑器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/markdownpadconfig.png&#34; alt=&#34;html head 编辑器&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;打开编辑器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;输入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;&#xA;    document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() {&#xA;        // 生成目录列表&#xA;        var outline = document.createElement(&amp;quot;ul&amp;quot;);&#xA;        outline.setAttribute(&amp;quot;id&amp;quot;, &amp;quot;outline-list&amp;quot;);&#xA;        outline.style.cssText = &amp;quot;border: 1px solid #ccc;&amp;quot;;&#xA;        document.body.insertBefore(outline, document.body.childNodes[0]);&#xA;        // 获取所有标题&#xA;        var headers = document.querySelectorAll(&#39;h1,h2,h3,h4,h5,h6&#39;);&#xA;        for (var i = 0; i &amp;lt; headers.length; i++) {&#xA;            var header = headers[i];&#xA;            var hash = _hashCode(header.textContent);&#xA;            // MarkdownPad2无法为中文header正确生成id，这里生成一个&#xA;            header.setAttribute(&amp;quot;id&amp;quot;, header.tagName + hash);&#xA;            // 找出它是H几，为后面前置空格准备&#xA;            var prefix = parseInt(header.tagName.replace(&#39;H&#39;, &#39;&#39;), 10);&#xA;            outline.appendChild(document.createElement(&amp;quot;li&amp;quot;));&#xA;            var a = document.createElement(&amp;quot;a&amp;quot;);&#xA;            // 为目录项设置链接&#xA;            a.setAttribute(&amp;quot;href&amp;quot;, &amp;quot;#&amp;quot; + header.tagName + hash)&#xA;            // 目录项文本前面放置对应的空格&#xA;            a.innerHTML = new Array(prefix * 4).join(&#39;&amp;amp;nbsp;&#39;) + header.textContent;&#xA;            outline.lastChild.appendChild(a);&#xA;        }&#xA;&#xA;    });&#xA;&#xA;    // 类似Java的hash生成方式，为一段文字生成一段基本不会重复的数字&#xA;    function _hashCode(txt) {&#xA;         var hash = 0;&#xA;         if (txt.length == 0) return hash;&#xA;         for (i = 0; i &amp;lt; txt.length; i++) {&#xA;              char = txt.charCodeAt(i);&#xA;              hash = ((hash&amp;lt;&amp;lt;5)-hash)+char;&#xA;              hash = hash &amp;amp; hash; // Convert to 32bit integer&#xA;         }&#xA;         return hash;&#xA;    }&#xA;&amp;lt;/script&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;保存&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;测试效果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;新建test.md编辑：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;## 标题1&#xA;标题1内容&#xA;### 标题11&#xA;标题11内容&#xA;### 标题12&#xA;标题12内容&#xA;## 标题2&#xA;标题2内容&#xA;### 标题21&#xA;标题21内容&#xA;### 标题22&#xA;标题22内容&#xA;## 标题3&#xA;标题3内容&#xA;### 标题31&#xA;标题31内容&#xA;### 标题32&#xA;标题32内容&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;导出html文件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/export.png&#34; alt=&#34;导出html文件&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;查看html文件&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/html.png&#34; alt=&#34;查看html&#34; /&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>记一次处理http请求返回json数据中文乱码问题</title>
      <link>http://sakyawang.github.io/java/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9Ejson%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>2015-07-10 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;项目中rest接口返回中文错误提示信息显示乱码。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;apache httpClient&lt;/p&gt;&#xA;&#xA;&lt;p&gt;spring mvc&lt;/p&gt;&#xA;&#xA;&lt;p&gt;tomcat&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;处理过程&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;分析理清问题&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;接口部署在本地tomcat上时，使用Apache httpClient客户端访问无乱码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接口部署到服务器上的tomcat时，使用Apache httpClient客户端访问返回结果中文乱码。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;初次排查&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;检查HttpClient请求Content-type为UTF-8，排除客户端编码问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;再次排查&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;查看本地tomcat编码为默认编码，服务器tomcat编码为UTF-8编码。怀疑是tomcat编码问题导致的，&#xA;修改本地tomcat编码为UTF-8，测试无乱码，排除tomcat编码问题。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;第三次排查&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;因为客户端和服务器编码都没有问题，怀疑是接口输出数据有问题。添加日志记录输出结果，发现数据无乱码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;怀疑是spring mvc 视图返回json字符串时编码有问题。百度一下发现spring mvc确实存在视图返回json字符串时使用的是iso-8859-1编码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;测试之，使用response out流输出json字符串，结果无乱码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;确定问题和spring mvc返回json数据编码导致。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;暂时使用输出流直接输出json字符串。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后续再测试网上提供的其他解决方案。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>post请求执行window open</title>
      <link>http://sakyawang.github.io/javascript/post%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8Cwindow-open/</link>
      <pubDate>2015-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般在html中打开新页面都是直接使用window.open(url)，打开新的页面是get请求，如果url有参数的话URL就会很长，在浏览器上会有参数显示。这里使用post请求可以避免该问题。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;处理方案&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;创建一个form表单method为post方式：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;&amp;quot; method=&amp;quot;post&amp;quot; name=&amp;quot;targetForm&amp;quot; id=&amp;quot;targetForm&amp;quot; target=&amp;quot;targetForm&amp;quot; onsubmit=&amp;quot;openWindow(&#39;targetForm&#39;);&amp;quot;&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;name1&amp;quot; id=&amp;quot;id1&amp;quot;/&amp;gt;&#xA;    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;name2&amp;quot; id=&amp;quot;id2&amp;quot;/&amp;gt;&#xA;&amp;lt;/form&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加onsubmit事件，执行openWindow（），具体js函数如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;function openWindow(name){    &#xA;    window.open(&#39;about:blank&#39;,name);     &#xA;}  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;关键点是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;onsubmit=&amp;quot;openWindow(&#39;targetForm&#39;);&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;中参数要是form表单的名字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后在操作的时候触发表单的提交事件：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;$(&amp;ldquo;#targetForm&amp;rdquo;).submit();&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>java des加密实践</title>
      <link>http://sakyawang.github.io/java/java-des%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>2015-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;工作中数据加密是C++实现的des加密，业务方是java语言。现在需要使用java对C++加密的内容进行解密。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;思路：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;根据C++的des加密算法实现，使用java进行逆向处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;具体代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import javax.crypto.Cipher;&#xA;import javax.crypto.SecretKey;&#xA;import javax.crypto.spec.SecretKeySpec;&#xA;&#xA;public class DESUtil {&#xA;&#xA;    private static final String Key = &amp;quot;d4odQA#5&amp;quot;;&#xA;    private static final String Algorithm = &amp;quot;DES&amp;quot;;  //定义 加密算法,可用 DES,DESede,Blowfish&#xA;&#xA;    // 加密字符串&#xA;    public static String encryptMode(String src) {&#xA;        String hexStr = &amp;quot;&amp;quot;;&#xA;        try {&#xA;            Cipher c1 = Cipher.getInstance(&amp;quot;DES/ECB/NoPadding&amp;quot;);&#xA;            SecretKey key = new SecretKeySpec(Key.getBytes(), Algorithm);//生成加密解密需要的Key&#xA;            c1.init(Cipher.ENCRYPT_MODE, key);&#xA;            byte[] bytes = c1.doFinal(getByte(src));&#xA;            hexStr = bytesToHexString(bytes);&#xA;        } catch (java.security.NoSuchAlgorithmException e1) {&#xA;            e1.printStackTrace();&#xA;        } catch (javax.crypto.NoSuchPaddingException e2) {&#xA;            e2.printStackTrace();&#xA;        } catch (java.lang.Exception e3) {&#xA;            e3.printStackTrace();&#xA;        }&#xA;        return hexStr;&#xA;    }&#xA;&#xA;    // 解密字符串&#xA;    public static String decryptMode(String hexStr) {&#xA;        String src = &amp;quot;&amp;quot;;&#xA;        try {&#xA;            Cipher c1 = Cipher.getInstance(&amp;quot;DES/ECB/NoPadding&amp;quot;);&#xA;            SecretKey deskey = new SecretKeySpec(Key.getBytes(), Algorithm);//生成加密解密需要的Key&#xA;            c1.init(Cipher.DECRYPT_MODE , deskey);&#xA;            byte[] bytes = c1.doFinal(hexString2Bytes(hexStr));&#xA;            src = new String(bytes).trim();&#xA;        } catch (java.security.NoSuchAlgorithmException e1) {&#xA;            e1.printStackTrace();&#xA;        } catch (javax.crypto.NoSuchPaddingException e2) {&#xA;            e2.printStackTrace();&#xA;        } catch (java.lang.Exception e3) {&#xA;            e3.printStackTrace();&#xA;        }&#xA;        return src;&#xA;    }&#xA;&#xA;    public static String bytesToHexString(byte[] digestByte) {&#xA;        byte[] rtChar = new byte[digestByte.length * 2];&#xA;        for (int i = 0; i &amp;lt; digestByte.length; i++) {&#xA;            byte b1 = (byte) (digestByte[i] &amp;gt;&amp;gt; 4 &amp;amp; 0x0f);&#xA;            byte b2 = (byte) (digestByte[i] &amp;amp; 0x0f);&#xA;            rtChar[i * 2] = (byte) (b1 &amp;lt; 10 ? b1 + 48 : b1 + 55);&#xA;            rtChar[i * 2 + 1] = (byte) (b2 &amp;lt; 10 ? b2 + 48 : b2 + 55);&#xA;        }&#xA;        return new String(rtChar).toLowerCase();&#xA;    }&#xA;&#xA;    public static byte[] getByte(String szSrc){&#xA;&#xA;        int length = szSrc.length();&#xA;        int a = length % 8;&#xA;        int b = length / 8;&#xA;        int len = 0;&#xA;        if (a == 0){&#xA;            len = b*8;&#xA;        }else{&#xA;            len = (b+1)*8;&#xA;        }&#xA;        byte[] src = new byte[len];&#xA;        byte[] bytes = szSrc.getBytes();&#xA;        for (int i = 0;i&amp;lt;bytes.length;i++){&#xA;            src[i] = bytes[i];&#xA;        }&#xA;        return src;&#xA;    }&#xA;&#xA;    public static byte[] hexString2Bytes(String src)&#xA;    {&#xA;        int len = src.length();&#xA;        byte[] ret = new byte[len/2];&#xA;        byte[] tmp = src.getBytes();&#xA;        for(int i=0; i&amp;lt;len/2; ++i )&#xA;        {&#xA;            ret[i] = uniteBytes(tmp[i*2], tmp[i*2+1]);&#xA;        }&#xA;        return ret;&#xA;    }&#xA;&#xA;    private static byte uniteBytes(byte src0, byte src1) {&#xA;        byte _b0 = Byte.decode(&amp;quot;0x&amp;quot; + new String(new byte[]{src0})).byteValue();&#xA;        _b0 = (byte) (_b0 &amp;lt;&amp;lt; 4);&#xA;        byte _b1 = Byte.decode(&amp;quot;0x&amp;quot; + new String(new byte[]{src1})).byteValue();&#xA;        byte ret = (byte) (_b0 | _b1);&#xA;        return ret;&#xA;    }&#xA;&#xA;    public static void main(String[] args) {&#xA;        String szSrc = &amp;quot;root&amp;quot;;&#xA;        System.out.println(&amp;quot;加密前的字符串:&amp;quot; + szSrc);&#xA;        String s = encryptMode(szSrc);&#xA;        System.out.println(&amp;quot;加密后的字符串:&amp;quot; + s);&#xA;        String s1 = decryptMode(s);&#xA;        System.out.println(&amp;quot;解密后的字符串:&amp;quot; + s1);&#xA;    }&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>微信公众平台开发入门</title>
      <link>http://sakyawang.github.io/微信公众平台/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;因工作需要，要在微信公众平台上进行服务号的开发，现记录下开发流程。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、IDEA14、Jdk1.7、微信公众平台测试号、外网域名&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;搭建基础开发环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;搭建web项目使用最简单的Servlet做消息入口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建WeChatServlet 继承 HttpServlet&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在web.xml中配置sevlet的url路径&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;wechat&amp;lt;/servlet-name&amp;gt;&#xA;&amp;lt;servlet-class&amp;gt;cn.wh.wechat.WeChatServlet&amp;lt;/servlet-class&amp;gt;&#xA;&amp;lt;/servlet&amp;gt;&#xA;&amp;lt;servlet-mapping&amp;gt;&#xA;    &amp;lt;servlet-name&amp;gt;wechat&amp;lt;/servlet-name&amp;gt;&#xA;    &amp;lt;url-pattern&amp;gt;/wechat&amp;lt;/url-pattern&amp;gt;&#xA;&amp;lt;/servlet-mapping&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在微信公众平台申请管理测试号&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index&#34;&gt;http://mp.weixin.qq.com/debug/cgi-bin/sandboxinfo?action=showinfo&amp;amp;t=sandbox/index&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;登陆之后设置URL和token，URL就是外网域名/项目名/wechat,必须是80端口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置消息通道认证&lt;/p&gt;&#xA;&#xA;&lt;p&gt;WeChatServlet的doGet方法如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;protected void doGet(HttpServletRequest request,&#xA;        HttpServletResponse response) throws ServletException, IOException {&#xA;    String signature = request.getParameter(&amp;quot;signature&amp;quot;);// 微信加密签名&#xA;    String timestamp = request.getParameter(&amp;quot;timestamp&amp;quot;);// 时间戳&#xA;    String nonce = request.getParameter(&amp;quot;nonce&amp;quot;);// 随机数&#xA;    String echostr = request.getParameter(&amp;quot;echostr&amp;quot;);// 随机字符串&#xA;    if (StringUtils.isBlank(signature) || StringUtils.isBlank(timestamp)|| StringUtils.isBlank(nonce)) {&#xA;        Writer out = response.getWriter();&#xA;        out.write(&amp;quot;error...&amp;quot;);&#xA;        out.flush();&#xA;        out.close();&#xA;        return;&#xA;    }&#xA;    // 重写totring方法，得到三个参数的拼接字符串&#xA;    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(3) {&#xA;        private static final long serialVersionUID = 2621444383666420433L;&#xA;&#xA;        public String toString() {&#xA;            return this.get(0) + this.get(1) + this.get(2);&#xA;        }&#xA;    };&#xA;    list.add(TOKEN);&#xA;    list.add(timestamp);&#xA;    list.add(nonce);&#xA;    Collections.sort(list);// 排序&#xA;    String tmpStr = new MySecurity().encode(list.toString(),&#xA;            MySecurity.SHA_1);// SHA-1加密&#xA;    Writer out = response.getWriter();&#xA;    if (signature.equals(tmpStr)) {&#xA;        out.write(echostr);// 请求验证成功，返回随机码&#xA;    } else {&#xA;        out.write(&amp;quot;&amp;quot;);&#xA;    }&#xA;    out.flush();&#xA;    out.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在微信公众平台测试页面点击提交请求会到WeChatServlet的doGet方法，如果验证通过返回验证码。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以上是在微信公众平台接入开发模式。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后续会写一些开发中用到的消息处理机制。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>sublime text2 安装插件</title>
      <link>http://sakyawang.github.io/sublime/sublime-text2-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;sublime tex t2本身自带了编程语言雷插件，可以通过Preferences&amp;ndash;&amp;gt;Browse Packages查看。&#xA;当然还有一些方便开发的插件需要单独安装。这里说一下sublime text2安装插件的操作流程。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、sublime text2&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;打开sublime 使用ctrl+` 调出控制台窗口，输入：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import urllib2,os; &#xA;pf=&#39;Package Control.sublime-package&#39;; &#xA;ipp=sublime.installed_packages_path(); &#xA;os.makedirs(ipp) &#xA;if not &#xA;    os.path.exists(ipp) &#xA;else &#xA;    None; &#xA;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));&#xA;open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()); &#xA;print &#39;Please restart Sublime Text to finish installation&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行完毕之后，重启sublime。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装插件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;ctrl+shift+P调出功能搜索框，输入 install 选择 install package，然后查找自己喜欢的插件 选择安装。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>mongodb安装配置</title>
      <link>http://sakyawang.github.io/mongodb/mongodb%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用mongoDB zip安装包安装配置mongodb。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;下载mongoDB安装包。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-3.0.4.zip&#34;&gt;https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-3.0.4.zip&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;解压缩安装包到 D盘根目录 D:\mongoDB&lt;/p&gt;&#xA;&#xA;&lt;p&gt;mongoDB目录下创建data\db目录和data\log目录&#xA;分别用来安装db和日志文件，在log文件夹下创建一个日志文件MongoDB.log。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;运行cmd.exe进入dos命令界面，执行下列命令，启动MongoDB&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd d:\mongoDB\bin&#xA;d:\mongodb\bin&amp;gt;mongod -dbpath &amp;quot;d:\mongoDB\data\db&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果看到信息显示当前监听端口27017则表示启动成功。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;测试连接&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;打开一个cmd窗口，进入mongodb的bin目录，输入mongo或者mongo.exe，&#xA;出现 connect to test 等信息说明测试通过，此时我们已经进入了test这个数据库。&#xA;输入exit或者ctrl+C可退出。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当mongod.exe被关闭时，mongo.exe 就无法连接到数据库了。因此每次想使用mongodb数据库都要开启mongod.exe程序，所以比较麻烦，此时我们可以将MongoDB安装为windows服务。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;运行cmd，进入bin文件夹，执行下列命令：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;d:\mongoDB\bin&amp;gt;mongod --dbpath &amp;quot;d:\mongoDB\data\db&amp;quot; --logpath &amp;quot;d:\mongoDB\data\log\MongoDB.log&amp;quot; --install --serviceName &amp;quot;MongoDB&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;　这里MongoDB.log就是开始建立的日志文件，&amp;ndash;serviceName &amp;ldquo;MongoDB&amp;rdquo; 设置服务名为MongoDB。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;　接着启动mongodb服务&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;d:\mongodb\bin&amp;gt;NET START MongoDB&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>gor创建个人博客</title>
      <link>http://sakyawang.github.io/golang/gor%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>2015-07-08 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;win7、golang、git&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;下载安装gor&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;gor github&lt;/a&gt;&#xA;里面有gor的安装和使用说明。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里主要说一下使用中遇到的问题：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行 go install github.com/wendal/gor/gor 操作的时候&#xA;会报错：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;connot find package &amp;ldquo;github.com/howeyc/fsnotify&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;处理方案如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/howeyc/fsnotify&#34;&gt;https://github.com/howeyc/fsnotify&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下载zip包。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;解压缩zip包内容到$GOPATH/src/github.com/howeyc/fsnotify&lt;/p&gt;&#xA;&#xA;&lt;p&gt;注意fsnotify目录下就是文件。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后再执行 go install github.com/wendal/gor/gor&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;搭建github个人博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;参考 &lt;a href=&#34;http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.html&#34;&gt;http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先要有一个github个人账号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;创建public仓库，名字以username.github.com命名。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;进入username.github.com仓库，选择右侧的setting。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在github Pages里面选择Launch automatic page generator按钮。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在新页面选择博客主题然后保存。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;访问username.github.io即可看到个人主页。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;提交个人博客到github&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用git 命令行或者客户端clone username.github.com库到本地git库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;把gor编译生成的compile文件加下的内容，添加更新到本地git库。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;提交更新到github。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;访问username.github.io查看更新。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;（因为七牛认证还未通过，暂时无法提供图片外链，认证通过之后补充操作截图）&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>本地搭建golang开发学习环境</title>
      <link>http://sakyawang.github.io/golang/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAgolang%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</link>
      <pubDate>2015-07-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;由于工作原因要学习golang，根据golang推荐学习方法搭建本地A tour of GO环境，记录操作过程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;5&#34;&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;win7 64位&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;下载并安装golang&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.golangtc.com/download&#34;&gt;http://www.golangtc.com/download&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;exe文件install安装&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;配置go环境变量&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;环境变量添加GOROOT为GO的安装目录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;环境变量添加GOPATH是GO的项目目录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当使用go get 获取内容时保存在GOPATH下，相当于workspace。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/goenv.png&#34; alt=&#34;go环境变量配置&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装完成之后，cmd下执行go&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/gocmd.png&#34; alt=&#34;go测试&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如图则安装配置成功&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;安装Mercurial&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Mercurial 是一个跨平台的分布式版本控制软件。Mercurial主要由Python语言实现，不过也包含一个用C实现的二进制比较工具。Mercurial一开始的主要运行平台是Linux。现在Mercurial已经被移植到Windows、Mac OS X 和大多数类Unix系统中。Mercurial主要由一个命令行程序组成，但现在也有了图形用户界面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你的系统中没有安装Mercurial，你就无法使用hg命令。&#xA; 下载：&lt;a href=&#34;https://mercurial.selenic.com/wiki/Download#Windows&#34;&gt;https://mercurial.selenic.com/wiki/Download#Windows&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;安装python2.7&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为Mercurial依赖python2.7 ，需安装python2.7&#xA;下载：&lt;a href=&#34;https://www.python.org/downloads/release/python-2710/&#34;&gt;https://www.python.org/downloads/release/python-2710/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;install安装配置环境变量&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;安装go-tour&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;墙外用户命令行下执行：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go get code.google.com/p/go-tour/gotour&lt;/p&gt;&#xA;&#xA;&lt;p&gt;墙内用户：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go get github.com/zhanming/go-tour-cn/gotour.cn&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go install github.com/zhanming/go-tour-cn/gotour.cn&lt;/p&gt;&#xA;&#xA;&lt;p&gt;成功的话会在，$GOPATH/bin目录下生成gotour.cn.exe文件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果获取失败，可以在github：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zhanming/go-tour-cn.git&#34;&gt;https://github.com/zhanming/go-tour-cn.git&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下载zip包文件。然后解压缩到GOPATH下面的src目录。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xj99v.com1.z0.glb.clouddn.com/tour.png&#34; alt=&#34;tour 目录结构&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;编译本地go tour&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go install github.com/zhanming/go-tour-cn/gotour.cn&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在$GOPATH/src/github&lt;strong&gt;/&lt;/strong&gt;*/gotour.cn 目录下命令行执行 go build&#xA;生成gotour.cn.exe&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;font size=&#34;4&#34;&gt;&lt;strong&gt;运行go tour&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;cmd下运行gotour.cn.exe 然后在浏览器输入&lt;a href=&#34;http://127.0.0.1:3999&#34;&gt;http://127.0.0.1:3999&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>