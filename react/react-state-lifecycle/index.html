<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>react-state-lifecycle</title>
  
    <meta name="description" content="React状态和生命周期">
  
    <meta name="author" content="Hao Wang">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/twitter/stylesheets/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">
 

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Sakyawang</a>
          <ul class="nav">
            
              


  <li><a href="/archive">Archive</a></li>


            
              


  <li><a href="/tags">Tags</a></li>


            
              


  <li><a href="/categories">Categories</a></li>


            
              


  <li><a href="/pages">Pages</a></li>


            
              


  <li><a href="/about">About Me</a></li>


            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        <div class="page-header">
  <h1>react-state-lifecycle </h1>
</div>

<div class="row">
  <div class="span8">
    <h1>React状态和生命周期</h1>

<p>考虑之前我们的时钟例子：</p>

<pre><code class="language-js">function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
</code></pre>

<p>到目前为止我们只学习了一种更新UI的方法。我们调用<code>ReactDOM.render()</code>来改变渲染输出。</p>

<p>在这里我们将学习如何真正的将<code>Clock</code>组件封装和可重用。它将设置自己的计时器，并且每秒更新一次。</p>

<p>我们从封装时钟对象开始：</p>

<pre><code class="language-js">function Clock(props) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
}

function tick() {
  ReactDOM.render(
    &lt;Clock date={new Date()} /&gt;,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
</code></pre>

<p>但是，它却忽略了一个关键的要求：<code>Clock</code>设置一个定时器并每秒更新一次UI的事实应该是<code>Clock</code>的实现细节。</p>

<p>理想情况下，我们想生成一次<code>Clock</code>，然后<code>Clock</code>更新自己的时间：</p>

<pre><code class="language-js">ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>

<p>要实现这种功能我们需要添加“state”到<code>Clock</code>组件中。</p>

<p>State与props很相似，但是它是组件私有的，完全由组件控制。</p>

<p>我们之前提到，定义为类的组件具有一些额外的功能。本地状态正是这样的：一个只有类组件具有的功能。</p>

<h2>把函数转换为类</h2>

<p>可以通过5步把函数式组件<code>Clock</code>转变为类组件：</p>

<ol>
<li>创建与函数同名的ES6语法的class，然后继承<code>React.Component</code>。</li>
<li>添加一个独立的<code>render()</code>空方法。</li>
<li>把函数式组件的内容转移到render方法中。</li>
<li>在<code>render()</code>方法中把<code>props</code>替换为<code>this.props</code>。</li>
<li>删除函数式声明组件。</li>
</ol>

<pre><code class="language-js">class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p><code>Clock</code>现在就是类式组件了。</p>

<p>这样我们就可以使用附加功能，例如本地状态和生命周期挂钩。</p>

<h2>添加本地状态到类组件中</h2>

<p>我们将通过三个步骤把<code>date</code>从<code>props</code>中转移到<code>state</code>中。</p>

<ol>
<li>在<code>render()</code>方法中把<code>this.props.date</code>替换为<code>this.state.date</code>：</li>
</ol>

<pre><code class="language-js">class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<ol>
<li>添加一个类构造器指定初始化的<code>this.state</code>:</li>
</ol>

<pre><code class="language-js">class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>注意我们是如何把<code>props</code>传递给基础构造器的：</p>

<pre><code class="language-js">constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
</code></pre>

<p>类组件应该总是调用基础构造器传入<code>props</code>。</p>

<ol>
<li>把<code>date</code>属性从<code>Clock</code>组件移除：</li>
</ol>

<pre><code class="language-js">ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>

<p>我们稍后将计时器代码添加到组件本身。</p>

<p>完整的代码如下：</p>

<pre><code class="language-js">class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>

<p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010">demo</a></p>

<p>接下来，我们将使时钟设置自己的计时器，并每秒更新一次。</p>

<h2>添加生命周期方法到类组件中</h2>

<p>在多组件应用中，在组件销毁时释放组件占用的资源是很重要的。</p>

<p>当<code>Clock</code>组件第一次被渲染到DOM时我们会设置一个定时器。在React中我们称之为“mounting”。</p>

<p>当<code>Clock</code>组件渲染的DOM移除时我们要销毁定时器。在React中我们称之为“unmounting”。</p>

<p>在React组件类中我们可以声明特定的方法在mount和unmount的时候运行相关代码：</p>

<pre><code class="language-js">class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {

  }

  componentWillUnmount() {

  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>这些方法称之为“生命周期钩子”。</p>

<p><code>componentDidMount()</code>钩子方法会在React组件输出渲染到DOM的时候触发。这就是设置定时器最佳时机：</p>

<pre><code class="language-js">componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }
</code></pre>

<p>注意我们把定时器的ID赋值给<code>this.timerID</code>。</p>

<p>虽然<code>this.props</code>和<code>this.state</code>是由React组件自身设置的具有特殊意义的字段，你同样可以设置自己需要的存储的数据到类中，这些数据不能用于视觉输出。</p>

<p>如果你在<code>render()</code>中没有使用一些数据，那么他们就不应该出现在<code>state</code>中。</p>

<p>我们会在<code>componentWillUnmount()</code>钩子方法中销毁定时器：</p>

<pre><code class="language-js">componentWillUnmount() {
	clearInterval(this.timerID);
}
</code></pre>

<p>最后，我们实现一个<code>tick()</code>方法供<code>Clock</code>组件每秒钟执行一次。</p>

<p><code>tick()</code>方法会调用<code>this.setSate()</code>方法定时更新组件的本地状态：</p>

<pre><code class="language-js">class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById('root')
);
</code></pre>

<p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010">demo</a></p>

<p>现在时钟每秒都在走着。</p>

<p>让我们快速回顾一下发生了什么以及调用方法的顺序：</p>

<ol>
<li><p>当把<code>&lt;Clock /&gt;</code>传递给<code>ReactDOM.render()</code>时，React调用<code>Clock</code>组件的构造方法。由于Clock需要显示当前时间，因此它会使用包含当前时间的对象来初始化<code>this.state</code>。我们稍后会更新这个状态。</p></li>

<li><p>React随后调用<code>Clock</code>组件的<code>render()</code>方法。这就是React如何知道屏幕上应该显示的内容。然后React更新DOM以匹配时钟的渲染输出。</p></li>

<li><p>当<code>Clock</code>组件输入插入到DOM元素后，React调用<code>componentDidMount()</code>生命周期钩子。在它里面，<code>Clock</code>组件要求浏览器设置一个定时器来每秒调用一次组件的<code>tick()</code>方法。</p></li>

<li><p>浏览器每秒调用<code>tick()</code>方法。在它里面，<code>Clock</code>组件通过用包含当前时间的对象调用<code>setState()</code>来调度UI更新。由于<code>setState()</code>调用，React知道状态已经改变，并再次调用<code>render()</code>方法来获取屏幕上应该显示的内容。这次，render（）方法中的this.state.date将会不同，所以渲染输出将包含更新的时间。 React会相应地更新DOM。</p></li>

<li><p>如果<code>Clock</code>组件被从DOM中删除，React调用<code>componentWillUnmount()</code>生命周期钩子，停止定时器。</p></li>
</ol>

<h2>正确使用状态</h2>

<p>关于<code>setState()</code>你该知道的三件事。</p>

<h3>不要直接修改状态</h3>

<p>比如，下面的代码不会重新渲染组件：</p>

<pre><code class="language-js">// Wrong
this.state.comment = 'Hello';
</code></pre>

<p>正确的是使用<code>setState()</code>：</p>

<pre><code class="language-js">// Correct
this.setState({comment: 'Hello'});
</code></pre>

<p>唯一可以分配<code>this.state</code>的地方是构造函数。</p>

<h2>状态更新可能是异步的</h2>

<p>React可能会将多个<code>setState()</code>调用批量处理为单个更新，以提高性能。</p>

<p>由于<code>this.props</code>和<code>this.state</code>可能会异步更新，所以你不应该依靠它们的值来计算下一个状态。</p>

<p>比如，下面的代码可能会更新出错：</p>

<pre><code class="language-js">// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
</code></pre>

<p>为了解决这个问题，使用接受函数而不是对象的形式使用<code>setState()</code>。该函数将接收前一个状态作为第一个参数，并将更新应用时的<code>props</code>作为第二个参数：</p>

<pre><code class="language-js">// Correct
this.setState((prevState, props) =&gt; ({
  counter: prevState.counter + props.increment
}));
</code></pre>

<p>上面使用的是箭头函数表示法，当然普通的函数写法也是可以的：</p>

<pre><code class="language-js">// Correct
this.setState(function(prevState, props) {
  return {
    counter: prevState.counter + props.increment
  };
});
</code></pre>

<h2>状态是合并更新的</h2>

<p>当调用<code>setState()</code>方法时，React会把传入的参数和原来的<code>state</code>进行合并。</p>

<p>比如，你的状态可能包含几个独立变量：</p>

<pre><code class="language-js">constructor(props) {
  super(props);
  this.state = {
    posts: [],
	comments: []
  };
}
</code></pre>

<p>然后你可以单独的调用<code>setState()</code>来更新它们：</p>

<pre><code class="language-js">  componentDidMount() {
    fetchPosts().then(response =&gt; {
      this.setState({
        posts: response.posts
      });
    });

    fetchComments().then(response =&gt; {
      this.setState({
        comments: response.comments
      });
    });
  }
</code></pre>

<p>合并是浅合并，所以<code>this.setState（{comments}）</code>表达式会保持<code>this.state.posts</code>不变，但会完全替换<code>this.state.comments</code>。</p>

<h2>数据流向下</h2>

<p>不论父组件还是子组件都不应该知道自身是有状态的还是无状态的，他们不应该关心自己是函数是组件还是类组件。</p>

<p>这就是为什么状态经常被称为本地或封装。除了拥有和设置它的组件之外，任何组件都无法访问它。</p>

<p>组件可以选择将其状态作为属性传递给其子组件：</p>

<pre><code class="language-js">&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
</code></pre>

<p>着同样适用于自定义组件：</p>

<pre><code class="language-js">&lt;FormattedDate date={this.state.date} /&gt;
</code></pre>

<p><code>FormattedDate</code>组件会通过<code>props</code>接收<code>date</code>，但是不会知道<code>date</code>是来自于<code>Clock</code>组件的<code>state</code>或者<code>props</code>，还是手动输入的：</p>

<pre><code class="language-js">function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}
</code></pre>

<p>这通常叫做自顶向下或者单向数据流。任何状态总是属于某些特定组件，并且从该状态派生的任何数据或UI只能影响组件树中“在其下面”的组件。</p>

<p>如果你把一个组件树想象为一个属性瀑布，每一个组件的状态就像二外的水源，它在任意点加入瀑布，顺着流下来。</p>

<p>为了显示所有的组件都是独立的，我们创建一个有三个<code>Clock</code>组件组成的<code>App</code>组件：</p>

<pre><code class="language-js">function App() {
  return (
    &lt;div&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById('root')
);
</code></pre>

<p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010">demo</a></p>

<p>我们可以看到每一个时钟都有自己的定时器并且独立的更新时间。</p>

<p>在React应用程序中，无论组件是有状态的还是无状态的，都被认为是组件的实现细节，可能随时间而改变。您可以在有状态组件内使用无状态组件，反之亦然。</p>

    <hr>
    <div class="pagination">
      <ul>
        <ul>
          
            <li class="prev"><a href="/React/react_components_props/" title="react_components_props">&larr; Previous</a></li>
          
          

            <li><a href="/archive">Archive</a></li>

          
            <li class="next"><a href="/react/React%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93/" title="React元素渲染">Next &rarr;</a></li>
          
          
        </ul>
      </ul>
    </div>
    <hr>
    
<div id="disqus_thread"></div>
<script>
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

  </div>
  
  <div class="span4">
    <h4>Published</h4>
    <div class="date"><span>2017-11-14</span></div>
    <br>
    <h4>Categories</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/categories/#react-ref">react <span>8</span></a>
</li>
    
    </ul>
    <br>
    <h4>Tags</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/tags/#react-ref">react <span>9</span></a>
</li>
    
      <li>
  <a href="/tags/#lifecycle-ref">lifecycle <span>1</span></a>
</li>
    
      <li>
  <a href="/tags/#state-ref">state <span>2</span></a>
</li>
    
    </ul>
  </div>
</div>

      </div>

      <footer>
        <p>&copy; Hao Wang 2013 
          with help from <a href="http://github.com/wendal/gor" target="_blank" title="Gor -- Fast Blog">Gor</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
		  and Idea from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
<script src="//cdnjscn.b0.upaiyun.com/libs/prettify/r298/prettify.min.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

    
<script type="text/javascript">

  var _gaq = _gaq || [];
  var pluginUrl = '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-123-12']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
